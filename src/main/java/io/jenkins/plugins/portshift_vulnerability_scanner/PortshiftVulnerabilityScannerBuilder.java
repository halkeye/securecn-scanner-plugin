package io.jenkins.plugins.portshift_vulnerability_scanner;

import static com.cloudbees.plugins.credentials.CredentialsMatchers.instanceOf;

import com.cloudbees.plugins.credentials.CredentialsProvider;
import com.cloudbees.plugins.credentials.common.StandardListBoxModel;
import com.cloudbees.plugins.credentials.common.StandardUsernameCredentials;
import com.cloudbees.plugins.credentials.common.StandardUsernameListBoxModel;
import com.cloudbees.plugins.credentials.common.StandardUsernamePasswordCredentials;
import hudson.AbortException;
import hudson.Extension;
import hudson.FilePath;
import hudson.Launcher;
import hudson.model.AbstractProject;
import hudson.model.Item;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.model.TopLevelItem;
import hudson.security.ACL;
import hudson.tasks.BuildStepDescriptor;
import hudson.tasks.Builder;
import hudson.util.FormValidation;
import hudson.util.ListBoxModel;
import io.jenkins.DockerRiskSeverity;
import io.jenkins.VulnerabilitySeverity;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.UUID;
import javax.annotation.Nonnull;
import jenkins.model.Jenkins;
import jenkins.tasks.SimpleBuildStep;
import net.sf.json.JSONObject;
import org.apache.commons.lang.StringUtils;
import org.jenkinsci.Symbol;
import org.jenkinsci.plugins.plaincredentials.StringCredentials;
import org.kohsuke.stapler.AncestorInPath;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.DataBoundSetter;
import org.kohsuke.stapler.QueryParameter;
import org.kohsuke.stapler.StaplerRequest;


public class PortshiftVulnerabilityScannerBuilder extends Builder implements SimpleBuildStep {

  protected static final String PLUGIN_NAME = "securecn-scanner";
  protected static final String DEFAULT_SECURE_CN_PRODUCTION_URL = "securecn.cisco.com";

  private String secureCnAccessKey;
  private String secureCnSecretKeyId;
  private String secretKey;
  private String imageName;
  private String url = DEFAULT_SECURE_CN_PRODUCTION_URL;
  private String dockerRegistryPasswordId;
  private String dockerRegistryUsername;
  private String dockerRegistryPassword;
  private String highestSeverityAllowed;
  private String highestSeverityAllowedDf;
  private Boolean pushLocalImage;

  @DataBoundConstructor
  public PortshiftVulnerabilityScannerBuilder(String secureCnAccessKey, String secureCnSecretKeyId, String imageName) {
    this.secureCnAccessKey = secureCnAccessKey;
    this.secureCnSecretKeyId = secureCnSecretKeyId;
    this.imageName = imageName;
  }

  @DataBoundSetter
  public void setSecureCnAccessKey(String secureCnAccessKey) {
    this.secureCnAccessKey = secureCnAccessKey;
  }


  @DataBoundSetter
  public void setSecureCnSecretKeyId(String secureCnSecretKeyId) {
    this.secureCnSecretKeyId = secureCnSecretKeyId;
  }


  @DataBoundSetter
  public void setImageName(String imageName) {
    this.imageName = imageName;
  }

  @DataBoundSetter
  public void setUrl(String url) {
    if (!StringUtils.isEmpty(url)) {
      this.url = url;
    }
  }

  @DataBoundSetter
  public void setDockerRegistryPasswordId(String dockerRegistryPasswordId) {
    this.dockerRegistryPasswordId = dockerRegistryPasswordId;
  }

  @DataBoundSetter
  public void setHighestSeverityAllowed(String highestSeverityAllowed) {
    this.highestSeverityAllowed = highestSeverityAllowed;
  }

  @DataBoundSetter
  public void setHighestSeverityAllowedDf(String highestSeverityAllowedDf) {
    this.highestSeverityAllowedDf = highestSeverityAllowedDf;
  }

  @DataBoundSetter
  public void setPushLocalImage(Boolean pushLocalImage) {
    this.pushLocalImage = pushLocalImage;
  }

  public String getSecureCnAccessKey() {
    return secureCnAccessKey;
  }

  public String getSecretKey() {
    return secretKey;
  }

  public String getImageName() {
    return imageName;
  }

  public String getUrl() {
    return url;
  }

  public String getHighestSeverityAllowed() {
    return highestSeverityAllowed;
  }

  public String getDockerRegistryUsername() {
    return dockerRegistryUsername;
  }

  public String getHighestSeverityAllowedDf() {
    return highestSeverityAllowedDf;
  }

  @Override
  public void perform(@Nonnull Run<?, ?> run, @Nonnull FilePath workspace, @Nonnull Launcher launcher,
      @Nonnull TaskListener listener)
      throws AbortException {

    checkConfiguration();

    setSecrets();

    int exitCode = PortshiftVulnerabilityScanExecuter
        .execute(run, workspace, launcher, listener, secureCnAccessKey, secretKey, imageName, url,
            highestSeverityAllowed, dockerRegistryUsername, dockerRegistryPassword, highestSeverityAllowedDf, pushLocalImage);
    listener.getLogger().println("exitCode: " + exitCode);

    String failedMessage = "Vulnerability scan has failed.";
    switch (exitCode) {
      case 0:
        listener.getLogger().println("Vulnerability scan has completed successfully.");
        break;
      case 4:
        throw new AbortException(failedMessage);
      default:
        // This exception causes the message to appear in the Jenkins console
        throw new AbortException(failedMessage);
    }
  }

  private void checkConfiguration() throws AbortException {

    if (StringUtils.isEmpty(secureCnAccessKey)) {
      throwMissingConfiguration("secureCnAccessKey");
    }

    if (StringUtils.isEmpty(secureCnSecretKeyId)) {
      throwMissingConfiguration("secureCnSecretKeyId");
    }

    if (StringUtils.isEmpty(imageName)) {
      throwMissingConfiguration("imageName");
    }
  }

  private void throwMissingConfiguration(String emptyField) throws AbortException {
    throw new AbortException(
        "Missing configuration. Please set the plugin configuration parameters before continuing.\n"
            + "empty field: " + emptyField);
  }

  private void setSecrets() throws AbortException {

    Collection<TopLevelItem> jenkinsItems = Jenkins.get().getItemMap().values();

    for (TopLevelItem jenkinsItem : jenkinsItems) {
      secretKey = getSecureCnSecretFromKey(jenkinsItem);
      if (secretKey != null) {
        break;
      }
    }
    if (secretKey == null) {
      throw new AbortException(
          "SecureCn credentials has not found for secret Id = " + secureCnSecretKeyId);
    }

    if (StringUtils.isEmpty(dockerRegistryPasswordId)) {
      return;
    }

    for (TopLevelItem jenkinsItem : jenkinsItems) {
      StandardUsernamePasswordCredentials dockerCreds = getDockerCredentialsFromKey(jenkinsItem);
      if (dockerCreds != null) {
        dockerRegistryPassword = dockerCreds.getPassword().getPlainText();
        dockerRegistryUsername = dockerCreds.getUsername();
        break;
      }
    }

    if (dockerRegistryPassword == null) {
      throw new AbortException(
          "docker registry credentials has not found for secret Id = " + dockerRegistryPasswordId);
    }
  }

  private StandardUsernamePasswordCredentials getDockerCredentialsFromKey(TopLevelItem jenkinsItem) {
    List<StandardUsernamePasswordCredentials> availableDockerSecrets = CredentialsProvider
        .lookupCredentials(StandardUsernamePasswordCredentials.class, jenkinsItem, ACL.SYSTEM, Collections.emptyList());

    for (StandardUsernamePasswordCredentials availableDockerSecret : availableDockerSecrets) {
      if (availableDockerSecret.getId().equals(dockerRegistryPasswordId)) {
        return availableDockerSecret;
      }
    }
    return null;
  }

  private String getSecureCnSecretFromKey(TopLevelItem jenkinsItem) {
    List<StringCredentials> availableSecrets = CredentialsProvider
        .lookupCredentials(StringCredentials.class, jenkinsItem, ACL.SYSTEM, Collections.emptyList());

    for (StringCredentials stringCredentials : availableSecrets) {

      if (stringCredentials.getId().equals(secureCnSecretKeyId)) {
        return stringCredentials.getSecret().getPlainText();
      }
    }
    return null;
  }

  // Overridden for better type safety.
  // If your plugin doesn't really define any property on Descriptor,
  // you don't have to do this.
  @Override
  public DescriptorImpl getDescriptor() {
    return (DescriptorImpl) super.getDescriptor();
  }


  /**
   * Descriptor for {@link io.jenkins.plugins.portshift_vulnerability_scanner.PortshiftVulnerabilityScannerBuilder}. Used
   * as a singleton. The class is marked as public so that it can be accessed from views.
   */
  @Symbol("secureCNVulnerabilityScanner")
  @Extension // This indicates to Jenkins that this is an implementation of an extension
  // point.
  public static final class DescriptorImpl extends BuildStepDescriptor<Builder> {

    /**
     * To persist global configuration information, simply store it in a field and call save().
     */
    private String secureCnAccessKey;
    private String imageName;
    private String url;
    private String highestSeverityAllowed;
    private String highestSeverityAllowedDf;
    private Boolean pushLocalImage;

    /**
     * In order to load the persisted global configuration, you have to call load() in the constructor.
     */
    public DescriptorImpl() {
      load();
    }

    @SuppressWarnings("unused")
    public ListBoxModel doFillSecureCnSecretKeyIdItems(@AncestorInPath Item context, @QueryParameter final String secureCnSecretKeyId) {

      if ( !hasPermission(context)) {
        return new StandardListBoxModel()
            .includeCurrentValue(secureCnSecretKeyId);
      }

      return new StandardListBoxModel()
          .includeEmptyValue()
          .includeAs(
              ACL.SYSTEM,
              context,
              StringCredentials.class).includeCurrentValue(secureCnSecretKeyId);
    }

    public ListBoxModel doFillDockerRegistryPasswordIdItems(@AncestorInPath Item context, @QueryParameter String dockerRegistryPasswordId) {
      if ( !hasPermission(context)) {
        return new StandardUsernameListBoxModel()
            .includeCurrentValue(dockerRegistryPasswordId);
      }

      return new StandardUsernameListBoxModel()
          .includeMatchingAs(
              ACL.SYSTEM,
              context,
              StandardUsernameCredentials.class,
              Collections.emptyList(), instanceOf(StandardUsernamePasswordCredentials.class))
          .includeCurrentValue(dockerRegistryPasswordId);
    }

    private boolean hasPermission(Item context) {
      if (context != null) {
        return context.hasPermission(Item.CONFIGURE);
      }
      return Jenkins.getInstance().hasPermission(Jenkins.ADMINISTER);
    }

    @SuppressWarnings("ResultOfMethodCallIgnored")
    public FormValidation doCheckSecureCnAccessKey(@QueryParameter final String secureCnAccessKey) {
      try {
        UUID.fromString(secureCnAccessKey);
        return FormValidation.ok();
      } catch (Exception e) {
        return FormValidation
            .error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidSecureCnAccessKey());
      }
    }

    public FormValidation doCheckImageName(@QueryParameter final String imageName) {
      try {
        if (StringUtils.isEmpty(imageName)) {
          return FormValidation
              .error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidImageName());
        }
        return FormValidation.ok();
      } catch (Exception e) {
        return FormValidation
            .error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidImageName());
      }
    }

    public FormValidation doCheckUrl(@QueryParameter final String url) {
      try {
        if (!isValidUrl(url) && !isValidUrl("https://" + url)) {
          return FormValidation.error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidUrl());
        }
        return FormValidation.ok();
      } catch (Exception e) {
        return FormValidation.error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidUrl());
      }
    }

    public FormValidation doCheckHighestSeverityAllowed(@QueryParameter final String highestSeverityAllowed) {
      try {
        if (!StringUtils.isEmpty(highestSeverityAllowed) && !isValidSeverity(highestSeverityAllowed)) {
          return FormValidation
              .error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidSeverity());
        }
        return FormValidation.ok();
      } catch (Exception e) {
        return FormValidation
            .error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidSeverity());
      }
    }

    public FormValidation doCheckHighestSeverityAllowedDf(@QueryParameter final String highestSeverityAllowedDf) {
      try {
        if (!StringUtils.isEmpty(highestSeverityAllowedDf) && !isValidSeverityDf(highestSeverityAllowedDf)) {
          return FormValidation
              .error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidDfSeverity());
        }
        return FormValidation.ok();
      } catch (Exception e) {
        return FormValidation
            .error(Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_errors_invalidSeverity());
      }
    }

    private boolean isValidUrl(String url) {
      try {
        new URL(url);
        return true;
      } catch (MalformedURLException e) {
        return false;
      }
    }

    private boolean isValidSeverity(String severity) {
      for (VulnerabilitySeverity vulnerabilitySeverity : VulnerabilitySeverity.values()) {
        if (vulnerabilitySeverity.name().equals(severity)) {
          return true;
        }
      }
      return false;
    }

    private boolean isValidSeverityDf(String severity) {
      for (DockerRiskSeverity dockerSeverity : DockerRiskSeverity.values()) {
        if (dockerSeverity.name().equals(severity)) {
          return true;
        }
      }
      return false;
    }

    public boolean isApplicable(Class<? extends AbstractProject> aClass) {
      // Indicates that this builder can be used with all kinds of project types
      return true;
    }

    /**
     * This human readable name is used in the configuration screen.
     */
    @Override
    @Nonnull
    public String getDisplayName() {
      return Messages.PortshiftVulnerabilityScannerBuilder_DescriptorImpl_DisplayName();
    }

    @Override
    public boolean configure(StaplerRequest req, JSONObject formData) throws FormException {
      // To persist global configuration information,
      // set that to properties and call save().
      secureCnAccessKey = formData.getString("secureCnAccessKey");
      imageName = formData.getString("imageName");
      url = formData.getString("url");
      highestSeverityAllowed = formData.getString("highestSeverityAllowed");
      highestSeverityAllowedDf = formData.getString("highestSeverityAllowedDf");
      pushLocalImage = formData.getBoolean("pushLocalImage");


      save();
      return super.configure(req, formData);
    }

    public String getSecureCnAccessKey() {
      return secureCnAccessKey;
    }

    public String getImageName() {
      return imageName;
    }

    public String getUrl() {
      return url;
    }

    public String getHighestSeverityAllowed() {
      return highestSeverityAllowed;
    }

    public String getHighestSeverityAllowedDf() {
      return highestSeverityAllowedDf;
    }

    public Boolean getPushLocalImage() {
      return pushLocalImage;
    }
  }
}

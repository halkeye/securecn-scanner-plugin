package io.jenkins.plugins.portshift_vulnerability_scanner;


import hudson.FilePath;
import hudson.Launcher;
import hudson.model.Computer;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.util.ArgumentListBuilder;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.URL;
import java.util.Arrays;
import java.util.UUID;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang.BooleanUtils;
import org.apache.commons.lang.StringUtils;


public class PortshiftVulnerabilityScanExecuter {

  public static final String EXEC_FILE_NAME = "securecn_deployment_cli";
  public static final String PRODUCTION_URL = "securecn.cisco.com";
  public static final String PASSWORD_MASK = "********";

  public static int execute(Run<?, ?> build, FilePath workspace, Launcher launcher, TaskListener listener,
      String secureCnAccessKey,
      String secretKey, String imageName, String url, String highestSeverityAllowed,
      String dockerRegistryUsername, String dockerRegistryPassword, String highestSeverityAllowedDf,
      Boolean pushLocalImage) {

    listener.getLogger().println(String
        .format(
            "Hello, parameters for SecureCN scanner:%nsecureCnAccessKey: %s%nsecretKey: %s%nimageName: %s%nurl: "
                + "%s%nhighestSeverityAllowed: %s%nhighestSeverityAllowedDf: %s%ndockerRegistryUsername:"
                + " %s%ndockerRegistryPassword: %s%npush local image: %s%n",
            secureCnAccessKey, PASSWORD_MASK, imageName, url, highestSeverityAllowed, highestSeverityAllowedDf,
            dockerRegistryUsername, StringUtils.isEmpty(dockerRegistryPassword) ? null : PASSWORD_MASK,
            pushLocalImage));
    try {
      ByteArrayOutputStream output = new ByteArrayOutputStream();
      int exitCode = runScan(launcher, listener, secureCnAccessKey, secretKey, imageName, url,
          output, highestSeverityAllowed, dockerRegistryUsername, dockerRegistryPassword, highestSeverityAllowedDf,
          pushLocalImage);
      if (exitCode == 0) {
        listener.getLogger().println("Execution succeeded.");
      } else {
        listener.getLogger().println("Execution failed.");
      }

      return exitCode;
    } catch (Exception e) {
      listener.getLogger().println("Execution failed: " + e.getMessage());
      listener.getLogger().println("Execution failed: " + Arrays.toString(e.getStackTrace()));
      return 4;
    }
  }

  private static int runScan(Launcher launcher, TaskListener listener,
      String secureCnAccessKey, String secretKey,
      String imageName, String url, ByteArrayOutputStream output,
      String highestSeverityAllowed, String dockerRegistryUsername, String dockerRegistryPassword,
      String highestSeverityAllowedDf, Boolean pushLocalImage)
      throws IOException, InterruptedException {

    String cliPath = downloadCliFile(listener, url, launcher);

    try {
      return runPortshiftCli(launcher, listener, secureCnAccessKey, secretKey, imageName, url, output,
          highestSeverityAllowed, dockerRegistryUsername, dockerRegistryPassword, highestSeverityAllowedDf,
          pushLocalImage, cliPath);
    } finally {
      deleteCliFromCurrentExecutor(launcher, cliPath);
    }
  }

  private static int runPortshiftCli(Launcher launcher, TaskListener listener, String secureCnAccessKey,
      String secretKey, String imageName, String url, ByteArrayOutputStream output, String highestSeverityAllowed,
      String dockerRegistryUsername, String dockerRegistryPassword, String highestSeverityAllowedDf,
      Boolean pushLocalImage, String portshiftCliPath) throws IOException, InterruptedException {

    Launcher.ProcStarter ps = launcher.launch();
    ArgumentListBuilder args = new ArgumentListBuilder();

    args.add(portshiftCliPath).add("run-vulnerability-scan").add("--access-key")
        .add(secureCnAccessKey).add("--secret-key").add(secretKey, true).add("--image-name").add(imageName);

    if (!StringUtils.isEmpty(url)) {
      args.add("--url").add(url);
    }

    if (!StringUtils.isEmpty(highestSeverityAllowed)) {
      args.add("--highest-severity-allowed").add(highestSeverityAllowed);
    }

    if (!StringUtils.isEmpty(highestSeverityAllowedDf)) {
      args.add("--df-highest-severity-allowed").add(highestSeverityAllowedDf);
    }

    if (!StringUtils.isEmpty(dockerRegistryPassword) && !StringUtils.isEmpty(dockerRegistryUsername)) {
      args.add("--username").add(dockerRegistryUsername).add("--password").add(dockerRegistryPassword, true);
    }

    if (BooleanUtils.isTrue(pushLocalImage)) {
      args.add("--local").add("--push-local");
    }

    ps.cmds(args);
    ps.stdin(null);
    ps.stdout(output);
    ps.stderr(listener.getLogger());

    listener.getLogger().println("Vulnerability scan in progress...");
    int join = ps.masks(args.toMaskArray()).join();

    listener.getLogger().println(output.toString());

    return join; // RUN !
  }

  private static void chmodCliExecutable(Launcher launcher, String portshiftCliPath)
      throws IOException, InterruptedException {
    Launcher.ProcStarter ps = launcher.launch();
    ArgumentListBuilder args = new ArgumentListBuilder();
    args.add("chmod").add("+x").add(portshiftCliPath);
    ps.cmds(args);
    ps.join();
  }

  private static void deleteCliFromCurrentExecutor(Launcher launcher, String portshiftCliPath)
      throws IOException, InterruptedException {
    Launcher.ProcStarter ps = launcher.launch();
    ArgumentListBuilder args = new ArgumentListBuilder();
    args.add("rm").add("-rf").add(portshiftCliPath.replace(EXEC_FILE_NAME, ""));
    ps.cmds(args);
    ps.join();
  }

  private static void deleteExecutableFromMaster(TaskListener listener, String cliPath) {
    File cli = new File(cliPath);
    if (!cli.delete()) {
      listener.getLogger().println("failed to delete cli from master in " + cliPath);
    }
  }

  private static String downloadCliFile(TaskListener listener, String mgmtUrl, Launcher launcher)
      throws IOException, InterruptedException {

    String cliFilePath = getCliPath(listener);

    File cliFileOnMaster = new File(cliFilePath);
    FilePath cliFileOnExecutorNode = Computer.currentComputer() != null ?
        new FilePath(Computer.currentComputer().getChannel(), cliFilePath) : new FilePath(cliFileOnMaster);

    try {
      mgmtUrl = StringUtils.isEmpty(mgmtUrl) ? PRODUCTION_URL : mgmtUrl;
      String urlToDownloadCli = "https://" + mgmtUrl + "/tools/cli/" + EXEC_FILE_NAME;

      listener.getLogger().println("download cli from: " + urlToDownloadCli);
      FileUtils.copyURLToFile(new URL(urlToDownloadCli), cliFileOnMaster);

      if (!cliFileOnExecutorNode.exists()) {
        listener.getLogger().println("cli file not exists on executor node. copying from master");

        try (FileInputStream fileStream = new FileInputStream(cliFileOnMaster)) {
          cliFileOnExecutorNode.copyFrom(fileStream);
        } finally {
          deleteExecutableFromMaster(listener, cliFilePath);
        }
      }

      chmodCliExecutable(launcher, cliFilePath);

    } catch (Exception e) {
      listener.getLogger().println("Exception: " + e.getMessage());
      throw e;
    }
    return cliFilePath;
  }

  private static String getCliPath(TaskListener listener) {
    String cliDirectory = "/tmp/" + UUID.randomUUID().toString() + "/";
    File theDir = new File(cliDirectory);
    if (!theDir.mkdirs()) {
      listener.getLogger().println("failed to create directory " + cliDirectory);
    }

    String portshiftCliPath = cliDirectory + EXEC_FILE_NAME;
    return portshiftCliPath;
  }
}
